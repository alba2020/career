public class Main {
    public static void print(Node start) {
        Node n = start;
        while (n != null) {
            System.out.printf("%d ", n.data);
            n = n.next;
        }
        System.out.println();
    }

    public static Node findK(Node start) {
        int i = 0;
        Node n = start;
        while(n != null) {
            n = n.next;
            i++;
        }
    }

    public static void main(String[] args) {
        Node head1 = new Node(1);
        for (int i = 2; i < 45; i++) {
            head1.append(i);
        }
        print(head1);
    }
}

// 8. А если размер связного списка известен?
// Чем поиск K-го элемента с конца отличается от поиска X-го элемента?

// 25. Если размер связного списка неизвестен, можно ли вычислить его?
// Как это отразится на времени выполнения?

// 41. Попробуйте применить рекурсивную реализацию.
// Если вы можете найти (K-1)-й элемент с конца, удастся ли вам найти K-й элемент?

// 67. В данном случае может быть полезно возвращать сразу несколько значений. В некоторых языках такая возможность не поддерживается напрямую, но обходные решения существуют в любом языке.
// Какие обходные решения такого рода вам известны?

// 126. Возможно ли итеративное решение? Представьте, что у вас имеются два указателя, установленные на соседние узлы, которые перемещаются с одинаковой скоростью по связному списку.
// Когда один указатель достигнет конца связного списка, где будет находиться другой?
